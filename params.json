{"name":"Graphlite","tagline":"embedded graph datastore","body":"![graphlite](https://raw.github.com/eugene-eeo/graphlite/master/art/logo-300.png)\r\n\r\n![Build Stats](https://travis-ci.org/eugene-eeo/graphlite.svg?branch=master)\r\n\r\nA simple social graph datastore using the SQLite library as\r\na backend. Graphlite provides storage for nodes- unsigned\r\nintegers that represent objects in another datastore, for\r\nexample the ID of your users and their posts.\r\n\r\n```\r\nfrom graphlite import Graph, V\r\ng = Graph(uri=':memory:', graphs=['follows'])\r\n\r\ng.store(V(1).knows(2))\r\ng.store(V(1).knows(3))\r\ng.store(V(2).knows(4))\r\n```\r\n\r\nThe relations, when stored in the SQLite database, are not\r\nindexed by their recency or any time based value, but rather\r\nby either the source or destination nodes. All queries are\r\nperformed using these clustered indexes as well.\r\n\r\nGraphlite aims to be performant and sane, as well as offering\r\na nice API for developers to work with. I also aim for the\r\nlibrary being thread-safe. Being inspired by FlockDB, Graphlite\r\nsupports both simple and compound arithmetic queries:\r\n\r\n```\r\ng.find(V(1).knows)\r\ng.find(V(1).knows).intersection(...)\r\ng.find(V(1).knows).difference(...)\r\ng.find(V(1).knows).union(...)\r\n```\r\n\r\nThey are pretty self explanatory. You can use them to simulate\r\ngraph traversal, although for some edge cases you may need the\r\nslower `traverse` method:\r\n\r\n```\r\ng.find(V(1).knows).traverse(V().knows)\r\n```\r\n\r\nI.e. for unavoidable situations to find out who does the people\r\nthat 1 know, know.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}