{"name":"Graphlite","tagline":"embedded graph datastore","body":"![graphlite](https://raw.github.com/eugene-eeo/graphlite/master/art/logo-300.png)\r\n\r\n\r\n![Build Stats](http://img.shields.io/travis/eugene-eeo/graphlite.svg)\r\n\r\nA simple MIT-licensed social graph datastore using the SQLite\r\nlibrary as a backend. Graphlite provides storage for nodes-\r\nunsigned integers that represent objects in another datastore,\r\nfor example the ID of your users and their posts.\r\n\r\n```python\r\nfrom graphlite import Graph, V\r\ng = Graph(uri=':memory:', graphs=['follows'])\r\n\r\ng.store(V(1).knows(2))\r\ng.store(V(1).knows(3))\r\ng.store(V(2).knows(4))\r\n```\r\n\r\nThe relations, when stored in the SQLite database, are not\r\nindexed by their recency or any time based value, but rather\r\nby either the source or destination nodes. All queries are\r\nperformed using these clustered indexes as well.\r\n\r\nGraphlite aims to be performant and sane, as well as offering\r\na nice API for developers to work with. I also aim for the\r\nlibrary being thread-safe. Being inspired by FlockDB, Graphlite\r\nsupports both simple and compound arithmetic queries, as well\r\nas queries to forwards and backwards relations:\r\n\r\n```python\r\ng.find(V(1).knows)\r\ng.find(V(1).knows).intersection(...)\r\ng.find(V(1).knows).difference(...)\r\ng.find(V().knows(1)).union(...)\r\n```\r\n\r\nThey are pretty self explanatory. You can use them to simulate\r\ngraph traversal, although for some edge cases you may need the\r\nslower `traverse` method:\r\n\r\n```python\r\ng.find(V(1).knows).traverse(V().knows)\r\ng.find(V(1).knows).traverse(...).traverse(...)\r\n```\r\n\r\nI.e. for unavoidable situations to find out who does the people\r\nthat 1 knows, know.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}